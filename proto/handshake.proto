syntax = "proto3";

package auraphone;

option go_package = "github.com/andrewarrow/auraphone-blue/proto";

// Handshake message - minimal, fits in single MTU (~128 bytes)
// Exchanged immediately on connection to establish sync state
message HandshakeMessage {
  string device_id = 1;
  string first_name = 2;
  int32 protocol_version = 3;
  bytes rx_photo_hash = 4;   // SHA-256 hash (32 bytes) of photo we RECEIVED from remote device
  bytes tx_photo_hash = 5;   // SHA-256 hash (32 bytes) of OUR photo available to send
  int32 profile_version = 6; // Profile version number, increments on any profile change
}

// Profile message - detailed info, sent after handshake
// Can be fragmented if it exceeds MTU
message ProfileMessage {
  string device_id = 1;
  string last_name = 2;
  string phone_number = 3;
  string tagline = 4;
  string insta = 5;
  string linkedin = 6;
  string youtube = 7;
  string tiktok = 8;
  string gmail = 9;
  string imessage = 10;
  string whatsapp = 11;
  string signal = 12;
  string telegram = 13;
  int32 profile_version = 14; // Profile version number
}

// Acknowledgment of photo transfer completion
message PhotoCompletionAck {
  string device_id = 1;
  fixed32 transfer_crc = 2;  // CRC-32 of complete photo data
  bool success = 3;
}

// Gossip Protocol Messages - For mesh network photo distribution
// =================================================================

// Single device's state in the mesh (photo + profile)
// NOTE: hardware_uuid is NOT included - it's ephemeral and changes frequently
// (iOS rotates for privacy, Android changes on factory reset/new owner)
// Hardware UUIDs are discovered via BLE scanning, not gossip
message DeviceState {
  string device_id = 1;           // Logical base36 ID (stable identity)
  bytes photo_hash = 2;           // SHA-256 hash (32 bytes) of their current photo
  int64 last_seen_timestamp = 3;  // Unix timestamp when this state was last observed
  string first_name = 4;          // Cached first name
  int32 profile_version = 5;      // Profile version number, increments on ANY profile change
}

// Gossip message - exchanged periodically between neighbors
// Contains sender's complete view of the mesh network
message GossipMessage {
  string sender_device_id = 1;           // Who is sending this gossip
  int64 timestamp = 2;                   // When this gossip was created
  repeated DeviceState mesh_view = 3;    // Sender's view of all devices in network
  int32 gossip_round = 4;                // Increments with each gossip broadcast
}

// Request for specific photo based on gossip information
// Sent when device learns about a photo it doesn't have
message PhotoRequestMessage {
  string requester_device_id = 1;  // Who wants the photo
  string target_device_id = 2;     // Whose photo we want
  bytes photo_hash = 3;            // Hash of the photo we want
}

// Request for profile details based on gossip information
// Sent when device learns about a profile version it doesn't have
message ProfileRequestMessage {
  string requester_device_id = 1;  // Who wants the profile
  string target_device_id = 2;     // Whose profile we want
  int32 expected_version = 3;      // Version number we're requesting
}

// Chunked Photo Transfer Protocol - For resilient photo delivery
// =================================================================

// Photo chunk message - single fragment of a photo transfer
// Sized to fit within MTU after protobuf encoding overhead
message PhotoChunkMessage {
  string sender_device_id = 1;     // Who is sending this chunk
  string target_device_id = 2;     // Who should receive this chunk
  bytes photo_hash = 3;            // SHA-256 hash of COMPLETE photo (32 bytes)
  int32 chunk_index = 4;           // Zero-based index of this chunk
  int32 total_chunks = 5;          // Total number of chunks in transfer
  bytes chunk_data = 6;            // Raw data for this chunk (typically 4KB)
  int64 timestamp = 7;             // When this chunk was sent
  uint32 chunk_crc = 8;            // CRC-32 of this chunk's data for integrity check
}

// Photo chunk acknowledgment - confirms receipt and requests missing chunks
// Supports resume after connection loss by listing missing chunk indices
message PhotoChunkAck {
  string receiver_device_id = 1;    // Who is acknowledging
  string sender_device_id = 2;      // Who sent the chunks
  bytes photo_hash = 3;             // Which photo transfer this acks
  int32 last_chunk_received = 4;    // Highest contiguous chunk index received
  repeated int32 missing_chunks = 5; // List of chunk indices still needed (for resume)
  bool transfer_complete = 6;       // True when all chunks received and verified
  int64 timestamp = 7;              // When this ack was sent
}
